var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"DocTestSetup  = quote\n    using BitOperations\nend","category":"page"},{"location":"api/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:type]","category":"page"},{"location":"api/#Functions","page":"API","title":"Functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:function]","category":"page"},{"location":"api/#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [BitOperations]\nOrder = [:type, :function]","category":"page"},{"location":"api/#BitOperations.bclear-Union{Tuple{T}, Tuple{T, Union{Signed, Unsigned}}} where T<:Integer","page":"API","title":"BitOperations.bclear","text":"bclear(x::T, bit::Integer)::T where {T<:Integer}\n\nReturns a modified copy of x, with bit bit cleared (set to zero).\n\n\n\n\n\n","category":"method"},{"location":"api/#BitOperations.bflip-Union{Tuple{T}, Tuple{T, Union{Signed, Unsigned}}} where T<:Integer","page":"API","title":"BitOperations.bflip","text":"bflip(x::T, bit::Integer)::T where {T<:Integer}\n\nReturns a modified copy of x, with bit bit flipped.\n\n\n\n\n\n","category":"method"},{"location":"api/#BitOperations.bflip-Union{Tuple{T}, Tuple{T, UnitRange{var\"#s1\"} where var\"#s1\"<:Union{Signed, Unsigned}}} where T<:Integer","page":"API","title":"BitOperations.bflip","text":"bflip(x::T, bits::UnitRange{<:Integer})::T where {T<:Integer}\n\nReturns a modified copy of x, with all bits in bit range bits flipped.\n\n\n\n\n\n","category":"method"},{"location":"api/#BitOperations.bget-Union{Tuple{T}, Tuple{T, Union{Signed, Unsigned}}} where T<:Integer","page":"API","title":"BitOperations.bget","text":"bget(x::T, bit::Integer)::Bool where {T<:Integer}\n\nGet the value of bit bit of x.\n\n\n\n\n\n","category":"method"},{"location":"api/#BitOperations.bget-Union{Tuple{T}, Tuple{T, UnitRange{var\"#s1\"} where var\"#s1\"<:Union{Signed, Unsigned}}} where T<:Integer","page":"API","title":"BitOperations.bget","text":"bget(x::T, bits::UnitRange{<:Integer})::T where {T<:Integer}\n\nGet the value of the bit range bits of x.\n\n\n\n\n\n","category":"method"},{"location":"api/#BitOperations.bmask-Union{Tuple{T}, Tuple{Type{T}, Union{Signed, Unsigned}}} where T<:Integer","page":"API","title":"BitOperations.bmask","text":"bmask(::Type{T}, bit::Integer)::T where {T<:Integer}\n\nGenerates a bit mask of type T with bit bit set to one.\n\n\n\n\n\n","category":"method"},{"location":"api/#BitOperations.bmask-Union{Tuple{T}, Tuple{Type{T}, UnitRange{var\"#s2\"} where var\"#s2\"<:Union{Signed, Unsigned}}} where T<:Integer","page":"API","title":"BitOperations.bmask","text":"bmask(::Type{T}, bits::UnitRange{<:Integer})::T where {T<:Integer}\n\nGenerates a bit mask of type T with bit-range bits set to one.\n\n\n\n\n\n","category":"method"},{"location":"api/#BitOperations.bset-Union{Tuple{T}, Tuple{T, Union{Signed, Unsigned}, Bool}} where T<:Integer","page":"API","title":"BitOperations.bset","text":"bset(x::T, bit::Integer, y::Bool)::T where {T<:Integer}\n\nReturns a modified copy of x, with bit bit set to y.\n\n\n\n\n\n","category":"method"},{"location":"api/#BitOperations.bset-Union{Tuple{T}, Tuple{T, Union{Signed, Unsigned}}} where T<:Integer","page":"API","title":"BitOperations.bset","text":"bset(x::T, bit::Integer)::T where {T<:Integer}\n\nReturns a modified copy of x, with bit bit set (to one).\n\n\n\n\n\n","category":"method"},{"location":"api/#BitOperations.bset-Union{Tuple{T}, Tuple{T, UnitRange{var\"#s1\"} where var\"#s1\"<:Union{Signed, Unsigned}, Integer}} where T<:Integer","page":"API","title":"BitOperations.bset","text":"bset(x::T, bits::UnitRange{<:Integer}, y::Integer)::T where {T<:Integer}\n\nReturns a modified copy of x, with bit range bits set to y.\n\n\n\n\n\n","category":"method"},{"location":"api/#BitOperations.bsizeof-Tuple{Any}","page":"API","title":"BitOperations.bsizeof","text":"bsizeof(x)\n\nReturns the data size of x in bits.\n\n\n\n\n\n","category":"method"},{"location":"api/#BitOperations.lsbget-Tuple{T} where T<:Integer","page":"API","title":"BitOperations.lsbget","text":"lsbget(x::Integer)::Bool\n\nReturns the value of the least significant bit of x.\n\n\n\n\n\n","category":"method"},{"location":"api/#BitOperations.lsbget-Union{Tuple{T}, Tuple{T, Union{Signed, Unsigned}}} where T<:Integer","page":"API","title":"BitOperations.lsbget","text":"lsbget(x::T)::T where {T <: Integer}\n\nReturns the value of the nbits least significant bits of x.\n\n\n\n\n\n","category":"method"},{"location":"api/#BitOperations.lsbmask-Union{Tuple{Type{T}}, Tuple{T}} where T<:Integer","page":"API","title":"BitOperations.lsbmask","text":"lsbmask(::Type{T})::T where {T<:Integer}\n\nGenerates a bit mask with only the least significant bit set.\n\n\n\n\n\n","category":"method"},{"location":"api/#BitOperations.lsbmask-Union{Tuple{T}, Tuple{Type{T}, Union{Signed, Unsigned}}} where T<:Integer","page":"API","title":"BitOperations.lsbmask","text":"lsbmask(::Type{T}, nbits::Integer)::T where {T<:Integer}\n\nGenerates a bit mask with only the nbits least significant bits set.\n\n\n\n\n\n","category":"method"},{"location":"api/#BitOperations.msbget-Tuple{T} where T<:Integer","page":"API","title":"BitOperations.msbget","text":"msbget(x::T)::Bool where {T<:Integer}\n\nReturns the value of the most significant bit of x.\n\n\n\n\n\n","category":"method"},{"location":"api/#BitOperations.msbget-Union{Tuple{T}, Tuple{T, Union{Signed, Unsigned}}} where T<:Integer","page":"API","title":"BitOperations.msbget","text":"msbget(x::T)::T where {T<:Integer}\n\nReturns the value of the nbits most significant bits of x.\n\n\n\n\n\n","category":"method"},{"location":"api/#BitOperations.msbmask-Union{Tuple{Type{T}}, Tuple{T}} where T<:Integer","page":"API","title":"BitOperations.msbmask","text":"msbmask(::Type{T})::T where {T<:Integer}\n\nGenerates a bit mask with only the most significant bit set.\n\n\n\n\n\n","category":"method"},{"location":"api/#BitOperations.msbmask-Union{Tuple{T}, Tuple{Type{T}, Union{Signed, Unsigned}}} where T<:Integer","page":"API","title":"BitOperations.msbmask","text":"msbmask(::Type{T}, nbits::Integer)::T where {T<:Integer}\n\nGenerates a bit mask with only the nbits most significant bits set.\n\n\n\n\n\n","category":"method"},{"location":"api/#BitOperations.zigzagdec","page":"API","title":"BitOperations.zigzagdec","text":"zigzagdec(x::Unsigned)::Signed\n\nZigzag-decode x, Google Protocol Buffers compatible.\n\n\n\n\n\n","category":"function"},{"location":"api/#BitOperations.zigzagenc","page":"API","title":"BitOperations.zigzagenc","text":"zigzagenc(x::Signed)::Unsigned\n\nZigzag-encode x, Google Protocol Buffers compatible.\n\n\n\n\n\n","category":"function"},{"location":"LICENSE/#LICENSE","page":"LICENSE","title":"LICENSE","text":"","category":"section"},{"location":"LICENSE/","page":"LICENSE","title":"LICENSE","text":"using Markdown\nMarkdown.parse_file(joinpath(@__DIR__, \"..\", \"..\", \"LICENSE.md\"))","category":"page"},{"location":"#BitOperations.jl","page":"Home","title":"BitOperations.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"BitOperations is a Julia package for bit and register operations. It is mainly intended for Julia code that needs to communicate with hardware (e.g. with a register-based memory model) or work with intricate binary data formats.","category":"page"},{"location":"","page":"Home","title":"Home","text":"While bit-manipulation operations are typically easy to implement on-the-fly, using a set of library functions (as provided by this package) improves code readability and reduces the potential for errors.","category":"page"},{"location":"","page":"Home","title":"Home","text":"BitOperations.jl conventions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Bit indices start at zero: bmask(Int, 0) == 0x01, bmask(Int, 1) == 0x02.\nBit ranges also start at zero, counting up from the least significant bit: bset(0x00, 0:7, 1) == 0xff.\nBit ranges must be of type UnitRange (start:stop) and not StepRange (start:step:stop). As a result, reverse indices are not supported.","category":"page"},{"location":"#Provided-functions","page":"Home","title":"Provided functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Basic bit operations:","category":"page"},{"location":"","page":"Home","title":"Home","text":"bsizeof, bmask, lsbmask, msbmask, bget, bset, bclear, bflip, lsbget, msbget","category":"page"},{"location":"","page":"Home","title":"Home","text":"Zigzag encoding/decoding (Google Protocol Buffers compatible):","category":"page"},{"location":"","page":"Home","title":"Home","text":"zigzagenc, zigzagdec","category":"page"}]
}
